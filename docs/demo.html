<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AI-Powered Curtain Wall Analysis Demo</title>
    <style>
        /* Global Styles */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Roboto', sans-serif;
            color: #fff;
        }
        /* Loader Styles */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        #loader h1 {
            font-size: 24px;
            color: #fff;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% {opacity: 0.5;}
            50% {opacity: 1;}
            100% {opacity: 0.5;}
        }
        /* Interface Styles */
        #interface {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
        }
        #interface h1 {
            font-size: 48px;
            margin-bottom: 10px;
        }
        #interface p {
            font-size: 18px;
            max-width: 400px;
        }
        /* Info Panel Styles */
        #infoPanel {
            position: absolute;
            top: 50%;
            right: -400px;
            transform: translateY(-50%);
            width: 400px;
            height: 80%;
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            overflow-y: auto;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.5);
            transition: right 0.5s;
            z-index: 10;
        }
        #infoPanel.active {
            right: 0;
        }
        #infoPanel h2 {
            margin-top: 0;
            font-size: 32px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        #infoPanel p {
            font-size: 16px;
            line-height: 1.5;
        }
        #closeInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 28px;
            cursor: pointer;
            color: #fff;
        }
        /* Canvas Styles */
        #threejsCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        /* Tooltip Styles */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.75);
            padding: 8px 12px;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 9;
        }
    </style>
</head>
<body>

<div id="loader">
    <h1>Loading AI Analysis Demo...</h1>
</div>

<div id="interface">
    <h1>AI Curtain Wall Analysis</h1>
    <p>Explore the 3D model below. Click on different components to see AI-driven analysis and estimations.</p>
</div>

<div id="infoPanel">
    <span id="closeInfo">&times;</span>
    <h2 id="elementTitle">Component Title</h2>
    <p id="elementDescription">Component description and AI analysis will appear here.</p>
    <canvas id="chartCanvas" width="350" height="200"></canvas>
</div>

<div class="tooltip" id="tooltip">Tooltip</div>

<!-- Three.js Canvas -->
<canvas id="threejsCanvas"></canvas>

<!-- Include Three.js Library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- Include OrbitControls -->
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

<script>
    // Loader
    window.addEventListener('load', () => {
        document.getElementById('loader').style.display = 'none';
    });

    // Three.js Variables
    let scene, camera, renderer, controls, raycaster, mouse, INTERSECTED;
    let tooltip = document.getElementById('tooltip');
    let infoPanel = document.getElementById('infoPanel');

    // Initialize Three.js Scene
    init();
    animate();

    function init() {
        // Scene Setup
        scene = new THREE.Scene();

        // Camera Setup
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(0, 200, 400);

        // Renderer Setup
        renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('threejsCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Controls Setup
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Light Setup
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(100, 200, 100);
        scene.add(directionalLight);

        // Raycaster for Interactivity
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Add 3D Model
        addModel();

        // Event Listeners
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('mousemove', onMouseMove, false);
        window.addEventListener('click', onMouseClick, false);
    }

    function addModel() {
        // Load a simplified 3D model of a curtain wall (for demo purposes, we'll create it procedurally)
        const wallGeometry = new THREE.BoxGeometry(300, 200, 10);
        const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x555555, side: THREE.DoubleSide });
        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
        wall.position.set(0, 100, 0);
        scene.add(wall);

        // Add windows (interactive components)
        const windowGeometry = new THREE.PlaneGeometry(50, 50);
        const windowMaterial = new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.DoubleSide });
        const components = [];

        for (let i = -2; i <= 2; i++) {
            for (let j = -1; j <= 1; j++) {
                const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial.clone());
                windowMesh.position.set(i * 60, j * 60 + 100, 5.5);
                windowMesh.userData = {
                    title: `Window ${i + 3}-${j + 2}`,
                    description: `This is an AI analysis for Window ${i + 3}-${j + 2}. It includes energy efficiency metrics and structural integrity assessments.`,
                    data: generateRandomData()
                };
                components.push(windowMesh);
                scene.add(windowMesh);
            }
        }

        // Store components for interaction
        scene.userData.components = components;
    }

    function generateRandomData() {
        // Generate random data for the chart
        const data = [];
        for (let i = 0; i < 5; i++) {
            data.push(Math.floor(Math.random() * 100));
        }
        return data;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseMove(event) {
        event.preventDefault();

        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;

        // Update tooltip position
        tooltip.style.left = event.clientX + 10 + 'px';
        tooltip.style.top = event.clientY + 10 + 'px';
    }

    function onMouseClick(event) {
        if (INTERSECTED) {
            showInfoPanel(INTERSECTED.userData);
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        controls.update();

        render();
    }

    function render() {
        // Update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // Calculate objects intersecting the picking ray
        const intersects = raycaster.intersectObjects(scene.userData.components);

        if (intersects.length > 0) {
            if (INTERSECTED != intersects[0].object) {
                if (INTERSECTED) INTERSECTED.material.color.set(0x87ceeb);
                INTERSECTED = intersects[0].object;
                INTERSECTED.material.color.set(0xffa500);

                // Update tooltip
                tooltip.style.opacity = 1;
                tooltip.innerHTML = INTERSECTED.userData.title;
            }
        } else {
            if (INTERSECTED) INTERSECTED.material.color.set(0x87ceeb);
            INTERSECTED = null;

            // Hide tooltip
            tooltip.style.opacity = 0;
        }

        renderer.render(scene, camera);
    }

    // Info Panel Logic
    function showInfoPanel(data) {
        document.getElementById('elementTitle').innerText = data.title;
        document.getElementById('elementDescription').innerText = data.description;
        drawChart(data.data);
        infoPanel.classList.add('active');
    }

    document.getElementById('closeInfo').addEventListener('click', () => {
        infoPanel.classList.remove('active');
    });

    // Chart Drawing Function
    function drawChart(data) {
        const canvas = document.getElementById('chartCanvas');
        const ctx = canvas.getContext('2d');

        // Clear previous chart
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw chart
        ctx.beginPath();
        ctx.moveTo(0, canvas.height - data[0] * 2);
        for (let i = 1; i < data.length; i++) {
            ctx.lineTo(i * (canvas.width / (data.length - 1)), canvas.height - data[i] * 2);
        }
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw data points
        ctx.fillStyle = '#00ff00';
        for (let i = 0; i < data.length; i++) {
            ctx.beginPath();
            ctx.arc(i * (canvas.width / (data.length - 1)), canvas.height - data[i] * 2, 4, 0, 2 * Math.PI);
            ctx.fill();
        }
    }
</script>

</body>
</html>



